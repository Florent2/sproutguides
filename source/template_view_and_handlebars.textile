h2. Using SC.TemplateView & Handlebars

This guide covers displaying content in the browser using Handlebars templates
and SC.TemplateView. After reading this guide, you will be able to:

* Describe the markup of your application using Handlebars-flavored HTML.
* Have your HTML update automatically when your data model changes.
* Handle user interaction by assigning views to sections of HTML.
* Integrate templates into existing applications.
* Build new applications entirely with templates.

endprologue.

h3. Handlebars

SproutCore comes bundled with "Handlebars":http://handlebars.strobeapp.com, a
semantic templating language.  These templates look like regular HTML, with
embedded handlebars expressions:

<html>
Hello, <b>{{name}}</b>!
</html>

You should store your Handlebars templates inside your application's
+resources/templates+ directory. Make sure you save them with a +.handlebars+
extension. At runtime, SproutCore will compile and load these templates so they
are available for you to use in your views.

In addition to the stock Handlebars templating library, SproutCore comes bundled
with a rich set of extensions that make templates bindings-aware by
default. That means that you define your template once, and any time the
underlying objects change, the template updates automatically. It's like magic.

h3. SC.TemplateView

An SC.TemplateView is a view that is responsible for rendering a Handlebars
template and inserting it into the DOM.

To tell the TemplateView which template to use, set its +templateName+ property.
For example, if I saved a template to a file called +sayhello.handlebars+, I
would set the +templateName+ property to +"sayhello"+.

<html filename="apps/myapp/resources/templates/sayhello.handlebars">
Hello, <b>{{name}}</b>!
</html>

<javascript>
var view = SC.TemplateView.create({
  templateName: 'sayhello',

  name: "Bob"
});
</javascript>

h3. Writing Templates

As you've already seen, you can print the value of a property by enclosing it in
a Handlebars expression, or a series of braces, like this:

<html>
  My new car is {{color}}.
</html>

This will look up and print the TemplateView's +color+ property.

Handlebars also comes with several built-in helpers that allow you to control
how your templates are rendered.

h4. {{#if}}, {{#else}}, and {{#unless}}

Sometimes you may only want to display part of your template if a property
exists. For example, let's say we have a view with a +person+ property that
contains an object with +firstName+ and +lastName+ fields:

<javascript>
SC.SayHelloView = SC.TemplateView.extend({
  person: SC.Object.create({
    firstName: "Joy",
    lastName: "Clojure"
  })
});
</javascript>

In order to display part of the template only if the +person+ object exists, we
can use the +{{#if}}+ helper:

<html>
{{#if person}}
  Welcome back, <b>{{person.firstName}} {{person.lastName}}</b>!
{{/if}
</html>

NOTE: {{#if}} is an example of a block expression. These allow you
to invoke a helper with a portion of your template. Block expressions look like
normal expressions except that they contain a hash before the helper name, and
require a closing expression.

h4. {{#with}}

Sometimes you may want to invoke a section of your template with a context
different than the SC.TemplateView. 

By using the +{{#with}}+ helper, we could write the template like this:

<html>
{{#with person}}
  Welcome back, <b>{{firstName}} {{lastName}}</b>!
{{/with}}
</html>

NOTE: {{#with}} changes the _context_ of the block you pass to it. The context
is the object on which properties are looked up. By default, the context is the
SC.TemplateView to which the template belongs.

h2. Advanced Topics
h3. Templates

At its simplest, a template is a function that generates a string of HTML when invoked with a
context object. Here's an example of a very basic template function:

<javascript>
function template(context) {
  return "Hello, <b>"+context.name+"</b>!";
}

var person = {
  name: "John"
};

template(person);
// returns "Hello, <b>John</b>!"
</javascript>

Of course, having to write your HTML as a series of string concatenations is
quite tedious, and if any properties change, you have to re-render the entire
thing.


- Using TemplateViews and Handlebars
    - What a template view is
    - What a template is
    - Bindings-aware templates with Handlebars
    - How to define templates
        - .handlebars files
        - SC.Handlebars.compile()
    - Handlebars
        - Basics
            - Properties with {{property}}
            - {{#with}}
            - {{#if}}
                - {{#else}}
                - {{#unless}}
            - Localized strings with {{loc}}
            - Binding element attributes with {{bindAttr}}
                - String values
                - Boolean values
                - Bind multiple classes
        - View Hierarchy
            - {{view}} / {{#view}}
                - Configuring bindings (contentBinding=...)
                - Setting id with id=...
                - Setting class with class=...
                - Binding class with classBinding=...
                - View look up relative to global space or parent view
        - Displaying Collections
            - #each
            - #collection
    - Using TemplateViews inside other views

