h2. Hooking Up to a Backend

This guide covers how to write a datasource using the API's in sproutcore 1.0 - 1.5. 
After reading this guide, you will be able to:

* Understand what a DataSource is, and where it fits into the SproutCore Data Stream
* Determine when and how to use a datasource
* Create your own DataSource and link it to your App

endprologue.

h3. What is a DataSource?

A datasource is the layer that connects your SproutCore application to your server. It knows how to talk to both your server and your "store":/model_overview.html#store. To start out you'll probably be using "fixtures":fixtures.html, but when your ready, you can make your own dataSource to talk to your server instead.

NOTE: A DataSource is different from the Store. The Store is the in memory storage for your records, while the DataSource is the communication layer to between the server and your store.

h3. When should I make my own DataSource?

If you want to be able to persist the data that your users enter, over sessions, then you'll want to save it, either to a server or to localStorage. The beauty of SproutCore's data layers is that you can write your app and seamlessly move from one data source to an other and nothing but your datasource need be changed.

NOTE: Using a DataSource is not the only way to get data into your store, but it is the recommended method todo so. If you already have code that talks to your server, you can use that instead, and manually insert your JSON objects into the store, this is a more advanced topic.

h3. A look at the API

Here we will look at an example API from the server, creating the server side is a digging deeper topic, for now you can have a look at the numerous examples for the todo app tutorial [link]. 

For the purpose of this guide, we are going to assume that we have a server that will provide us with a basic "RESTful API":http://en.wikipedia.org/wiki/Representational_State_Transfer#RESTful_web_services. If we wanted to get a list of all Todo items, we would send a GET request to:
<plain>
GET: /todos/
</plain>
Which will return a "JSON":http://en.wikipedia.org/wiki/Json array like:
<javascript>
[
  {
    "id": 1,
    "title": "Learn to use Sproutcore",
    "done": false
  },
  {
    "id": 2,
    "title": "Something",
    "done": false
  }
]
</javascript>
We can also POST to this URL with JSON in the body, to create a new object.

<plain>
POST: /todos/
{
  "title": "Profit!",
  "done": false
}
</plain>
The server will create an ID for us.
<javascript>
{
  "id": 3,
  "title": "Profit!",
  "done": false
}
</javascript>

If we specify an ID in the url:
<plain>
GET: /todos/3
</plain>
You'll see just one object returned:
<javascript>
{
  "id": 3,
  "title": "Profit!",
  "done": false
}
</javascript>
The API also allows us to send a PUT to update an object or DELETE to remove it.

With this basic understanding of how the server works, we can get started writing our dataSource.

h3. Setup

Now we'll walk through the steps of setting up a default dataSource.

h4. Creating a dataSource

To generate a dataSource template use the command:

<plain>
sc-gen data-source MyApp.RESTDataSource
</plain>

NOTE: Anywhere you see MyApp, replace this with the name of the application that your building.

This will make a file in +apps/my_app/data_sources/simple.js+. This file will be stubbed with the default functions that will get called by the store.

h4. Linking to the Store

The next step is linking the new dataSource to our apps store. By default the store will be "using Fixtures":fixtures.html, in +core.js+ you'll see:

<javascript>
  store: SC.Store.create().from(SC.Record.fixtures)
</javascript>

Replace this with our dataSource

<javascript>
  store: SC.Store.create().from('MyApp.RESTDataSource')
</javascript>

This will tell the store to use our dataSource when trying to find data.

NOTE: As you can see we are replacing a JavaScript Object: +SC.Record.fixtures+ with a string +'MyApp.RESTDataSource'+. This is because our dataSource won't have been initialised yet. The first time the store tries to access the dataSource it will convert the string to an object, and save it for future reference. See "Core Concepts":core_concepts.html#property-paths for more info.

h3. Writing The DataSource

h4. Our First Fetch

The first thing that our app will likely do is to fetch a bunch of data. most apps aren't any good without data. this is usually done via a "query":/queries.html. The query for finding all todos will look like:

<javascript>
  MyApp.QUERY_ALL_TODOS = SC.Query.local(MyApp.Todo)
</javascript>

NOTE: Our dataSource will be written assuming that "local queries":/queries.html#local_queries are being used, as this is almost always what you want, remote queries will be covered in a separate guide.

When you call +App.store.find(MyApp.QUERY_ALL_TODOS)+, the store will first find any matching records in our app store, and return a recordArray containing those (or an empty recordArray, if nothing matches). This RecordArray is linked to the query so that it will automatically update any time the query matches a new record. After it has returned, the store will call 'fetch' on its attached dataSource. 

This is when we get to take action. The generated dataSource will have made this for us:

<javascript>
  fetch: function(store, query) {

    // TODO: Add handlers to fetch data for specific queries.  
    // call store.dataSourceDidFetchQuery(query) when done.

    return NO ; // return YES if you handled the query
  },
</javascript>

Currently this dataSource will not do anything, except return NO. This tells the store that we are not going to handle this query.

We also get given a hint of what we need todo next. When the server responds, we will call +store.dataSourceDidFetchQuery(query)+ to let the store know that this query has been updated.

Now we want to fetch all the Todo's

<javascript>
fetch: function(store, query) {
  SC.Request.getURL('/todos/').json()
    .notify(this, 'fetchDidComplete', store, query)
    .send()

  return YES;
},

fetchDidComplete: function(response, store, query) {
  if(SC.ok(response)) {
    var recordType = query.get('recordType'),
        records = response.get('body');
    
    store.loadRecords(recordType, records);
    store.store.dataSourceDidFetchQuery(query);
    
  } else {
    // Tell the store that your server returned an error
    store.dataSourceDidErrorQuery(query, response);
  }
}
</javascript>

Our Fetch function is pretty simple. For now we are constructing an Request to send to the server.
"SC.Request":http://docs.sproutcore.com/symbols/SC.Request.html is SproutCore's simple wrapper around an Ajax call.

NOTE: You are not restricted to using an SC.Request inside of a DataSource, but it is advised that you don't go making calls to your server from just anywhere in your app.

".getURL":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request.getUrl tells our request that we want to use the GET method to contact the given url. You can also use 
"putUrl":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request.putUrl,
"postUrl":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request.postUrl or
"deleteUrl":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request.deleteUrl.

".json":http://docs.sproutcore.com/symbols/SC.Request.html#json lets the request know that we are expecting the server to send back JSON, so it will automatically parse it for us. Without this the return value would be a string. We could also have called +.xml()+ if your server talks XML.

".notify":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request#notify sets the callback method. By default SC.Requests are asynchronous, so the app can keep running while waiting for the server. The parameters used here are:
  # +this+ {Object} The target object that the action will run on
  # +'fetchDidComplete'+ {String} The name of the function that is located on `target` that will get called
  # +store, query+ {Any Objects} All following parameters will get passed into the call back

".send":http://docs.sproutcore.com/symbols/SC.Request.html#SC.Request#send will now actually send the built up request and return immediately (as we have kept the default async behaviour), without waiting for the server. 

NOTE: +.send()+ also takes a +String+ parameter for the +POST+ and +PUT+ methods to send as the body of the request.

When the server does finally get back to use, our callback method +fetchDidComplete+ will get called. The first parameter is the SC.Response related to the Request we just sent. Any following parameters are the ones we passed into +.notify()+: +store+ and +query+.

First thing we do when the response comes back is check to see if there was an error or not.
"SC.ok":http://docs.sproutcore.com/symbols/SC.html#SC.ok will do this for us.

If all is good then we can load the records into the store. First we get the recordType that is stored in the query, so we can tell the store. For us it will be +MyApp.Todo+.

Then we get our records with +response.get('body')+, this is where the JSON string is converted into JS objects for us. If we did not call +.json()+ on the Request, then it would return a string.
This works because our server response with an array at the top level of the JSON. If your server returned something like:
<javascript>
{
  length: 1,
  records: [
    {
      "id": 1,
      "title": "Learn to use Sproutcore",
      "done": false
    }
  ]
}
</javascript>

Then we would use this instead:

<javascript>
var body = response.get('body')
    records = body.records;
</javascript>
NOTE: Note how we didn't use .get('records'), this is because the JSON is converted into plain JS, not  SC.Object's

Now we call "loadRecords":http://docs.sproutcore.com/symbols/SC.Store.html#SC.Store#loadRecords on the store to actually put our data into the store. The first parameter is the Record Type of the objects you are going to load. The second is an array of plain JS object hashes containing your records data.

WARNING: You need to make sure that your data hashes have their primaryKey properties, in this case '+id+', see "this note":#a-records-primarykey for more details.

NOTE: This is the usual way of calling loadRecords, but it can be called with a few different signatures. This allows for quite complex behaviour, such as loading multiple record types at once. These will be covered by other guides.

This is followed by ".dataSourceDidErrorQuery":http://docs.sproutcore.com/symbols/SC.Store.html#SC.Store#dataSourceDidErrorQuery to let the store know that we have finished loading records, and it is now time to update the passed in query. The query that we passed in is the one that was given to us by +fetch+, and we passed through to the callback.

If the server returned an error, such as +404+ Not Found, or +500+ series of server errors, then we'll let the store know. with ".dataSourceDidErrorQuery":http://docs.sproutcore.com/symbols/SC.Store.html#SC.Store#dataSourceDidErrorQuery. This sets the query into an error state, which you can later check for and deal with.

h4. Gaining Flexibility

This design is simple, but as you can see, not very flexible, it only allows for one url. That wont get us very far. But given that all of our records are going to have a very similar URL, it should be simple to get this url to be dynamically generated.

...

h4. Going for Creation

POST

h4. Change of Mind

PUT 

Updating data is a similar process to creation, we just need to make sure that anything that comes back from the server remains linked to what we have.

h4. Ahh, Refreshing

GET

h4. Feeling Destructive

DELETE

h3. Things to Note

h4. A Records PrimaryKey

By default, SproutCore sets the primaryKey property of records to 'guid'. A common convention of many server side APIs is to use just 'id'.
To make your records work with this, you can override the default in your Model files.
<javascript>
App.Todo = SC.Record.extend({
  primaryKey:'id'
})
</javascript>
You may set this to anything that you want, if your server uses, for example, +TID+ for your todo's id, you must set +primaryKey:'TID'+. Like normal JS properties, this is case sensitive.

h4. Prepare for a Change

The dataSource as we have it now is handy, but as people have been using it, we have discovered that there are many improvements that can be made. As a courtesy we are just letting you know that a future (yet undecided) version of SproutCore is going to have a vastly updated DataSource layer.

Don't hold back developing your awesome app now. Just know, and be excited, that there are great improvements coming.

h3. Advanced topics

h4. Managing Many Records with a Bulk API

h4. Datasource for sparseArray

h4. Cascading Datasource

h4. Fetching a Query with Multiple Data Types

h4. Datasource for Remote Query

h3. Changelog

* Month DD, YYYY: initial version by "Geoffrey Donaldson":credits.html#geoffreyd
